-- Autogenerated with DRAKON Editor 1.32
local table = table
local string = string
local pairs = pairs
local ipairs = ipairs
local type = type
local tostring = tostring
local tonumber = tonumber
local print = print
local math = math
local os = os

local global_cfg = global_cfg
local globs = globs

local vud = require("vud")
local ej = require("ej")

local clock = require("clock")
local log = require("log")
local digest = require("digest")
local fiber = require("fiber")
local utils = require("utils")
local fun = require("fun")
local lic = require("lic")
local json = require("json")

local utf8 = require("lua-utf8")


local search_yield = 0.02
local current_version = 20180619
local root_folder_id = "1"

local db = require(global_cfg.db)

setfenv(1, {}) 

function access(data, grant, user_id, admin)
    -- item 1731
    local message = access_core(
    	data,
    	grant,
    	user_id,
    	admin
    )
    -- item 1732
    if message then
        -- item 1737
        return message
    else
        -- item 1736
        return nil
    end
end

function access_core(data, grant, user_id, admin)
    -- item 2101
    local count = 0
    -- item 1668
    local space_id = data.workspace
    -- item 1665
    local message = check_admin_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 1666
    if message then
        -- item 1657
        return message, count
    else
        -- item 2969
        db.begin()
        -- item 1685
        if grant then
            for _, uid in ipairs(data.users) do
                -- item 1897
                log_user_event(
                	user_id,
                	"grant",
                	{principal=uid, space=space_id, 
                	op=data.operation}
                )
                -- item 2970
                db.rights_insert(
                	space_id,
                	uid,
                	data.operation,
                	{}
                )
            end
        else
            for _, uid in ipairs(data.users) do
                -- item 1898
                log_user_event(
                	user_id,
                	"revoke",
                	{principal=uid, space=space_id, 
                	op=data.operation}
                )
                -- item 2971
                db.rights_delete(
                	space_id,
                	uid,
                	data.operation
                )
            end
        end
        -- item 3064
        local sdata = db.space_get(space_id)
        -- item 3018
        local rights = db.rights_get_by_space(
        	space_id
        )
        -- item 3020
        local admins = get_admins(rights)
        -- item 1714
        if #admins == 0 then
            -- item 1717
            message = "ERR_LAST_ADMIN"
            -- item 2972
            db.rollback()
            -- item 1657
            return message, count
        else
            -- item 2089
            if ((grant) and (not (admin))) and (not (data.operation == "read")) then
                -- item 2083
                local max_users = get_max_users(sdata)
                local actual_users = get_actual_users(
                	rights
                )
                -- item 2084
                if actual_users > max_users then
                    -- item 2087
                    message = "ERR_USER_LIMIT"
                    count = actual_users
                    -- item 2972
                    db.rollback()
                    -- item 1657
                    return message, count
                else
                    -- item 2116
                    update_space_limits_core(
                    	space_id,
                    	admins
                    )
                    -- item 2973
                    db.commit()
                    -- item 1709
                    return nil
                end
            else
                -- item 2116
                update_space_limits_core(
                	space_id,
                	admins
                )
                -- item 2973
                db.commit()
                -- item 1709
                return nil
            end
        end
    end
end

function add_child(space_id, folder_id, child_id, user_id)
    -- item 401
    local fdata = db.folder_get(space_id, folder_id)
    -- item 497
    if fdata.type == "folder" then
        -- item 3114
        db.folder_tree_upsert(
        	space_id,
        	child_id,
        	folder_id
        )
        -- item 501
        return nil
    else
        -- item 500
        return "ERR_NOT_FOLDER"
    end
end

function add_to_recent(space_id, folder_id, user_id)
    -- item 1470
    local data = {
    	when = clock.time()
    }
    -- item 1471
    db.recent_upsert(
    	space_id,
    	folder_id,
    	user_id,
    	data
    )
    -- item 1472
    local urecent = db.recent_get_by_user(user_id)
    -- item 1473
    if #urecent > global_cfg.max_recent then
        -- item 1476
        local compare_when = function(left, right)
        	local lwhen = left[4].when
        	local rwhen = right[4].when
        	return lwhen < rwhen
        end
        -- item 1477
        table.sort(urecent, compare_when)
        -- item 1478
        local n = #urecent - global_cfg.max_recent
        local redundant = fun.take_n(n, urecent)
        for i, red in fun.iter(redundant) do
            -- item 1479
            db.recent_delete(
            	red[1],
            	red[2],
            	red[3]
            )
        end
    end
end

function add_to_trash(space_id, folders)
    for _, folder_id in ipairs(folders) do
        -- item 3106
        db.trash_insert(space_id, folder_id)
    end
end

function add_tree_node(space_id, folder_id, fdata, depth, lines)
    -- item 1017
    if fdata.type == "folder" then
        -- item 1010
        local me = {
        	space_id = space_id,
        	id = folder_id,
        	name = fdata.name,
        	depth = depth
        }
        -- item 1016
        table.insert(lines, me)
        -- item 1020
        local children = {}
        -- item 3141
        local kids = get_child_folders(
        	space_id,
        	folder_id
        )
        for _, child_id in ipairs(kids) do
            -- item 1023
            local child_data = db.folder_get(
            	space_id,
            	child_id
            )
            -- item 1034
            table.insert(
            	children,
            	{
            		id = child_id,
            		fdata = child_data
            	}
            )
        end
        -- item 1035
        table.sort(
        	children,
        	compare_fdata
        )
        -- item 1012
        local cdepth = depth + 1
        for _, child in ipairs(children) do
            -- item 1015
            add_tree_node(
            	space_id,
            	child.id,
            	child.fdata,
            	cdepth,
            	lines
            )
        end
    end
end

function build_copy_plan(space_id, folder_id, plan)
    -- item 2315
    fiber.yield()
    -- item 3139
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    -- item 2310
    plan[folder_id] = utils.list_to_set(
    	children
    )
    for _, child_id in ipairs(children) do
        -- item 2314
        build_copy_plan(
        	space_id,
        	child_id,
        	plan
        )
    end
end

function by_count(left, right)
    -- item 2881
    return left.count > right.count
end

function calculate_depth(space_id, folder_id)
    -- item 1375
    local depth = 0
    while true do
        -- item 1381
        depth = depth + 1
        -- item 1383
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 1377
        if folder_id then
            
        else
            break
        end
    end
    -- item 1376
    return depth
end

function can_edit_folder(space_id, folder_id, user_id, admin)
    -- item 650
    local message = check_write_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 651
    if message then
        -- item 665
        return false, message
    else
        -- item 653
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 654
        if fdata then
            -- item 691
            if fdata.deleted then
                -- item 693
                message = "ERR_NOT_FOUND"
                -- item 665
                return false, message
            else
                -- item 664
                return true, fdata
            end
        else
            -- item 656
            message = "ERR_NOT_FOUND"
            -- item 665
            return false, message
        end
    end
end

function check_admin_access(space_id, user_id, admin)
    -- item 1205
    local sdata = db.space_get(space_id)
    -- item 1206
    if sdata then
        -- item 1209
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	admin
        )
        -- item 1198
        if access == "admin" then
            -- item 1201
            return nil
        else
            -- item 1208
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 1207
        return "ERR_NOT_FOUND"
    end
end

function check_dst_folder(space_id, folder_id, user_id, admin)
    -- item 1095
    local message = check_write_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 1096
    if message then
        -- item 1107
        return message
    else
        -- item 1097
        local fdata = find_folder(
        	space_id,
        	folder_id
        )
        -- item 1098
        if fdata then
            -- item 1102
            if fdata.type == "folder" then
                -- item 1106
                return nil
            else
                -- item 1105
                return "ERR_NOT_FOLDER"
            end
        else
            -- item 1101
            return "ERR_NOT_FOUND"
        end
    end
end

function check_read_access(space_id, user_id, admin)
    -- item 2951
    local sdata = db.space_get(space_id)
    -- item 360
    if sdata then
        -- item 3034
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	admin
        )
        -- item 36
        if ((access == "admin") or (access == "write")) or (access == "read") then
            -- item 39
            return nil, access, sdata.public
        else
            -- item 362
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 361
        return "ERR_NOT_FOUND"
    end
end

function check_write_access(space_id, user_id, admin)
    -- item 2952
    local sdata = db.space_get(space_id)
    -- item 366
    if sdata then
        -- item 3035
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	admin
        )
        -- item 114
        if (access == "admin") or (access == "write") then
            -- item 117
            return nil
        else
            -- item 368
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 367
        return "ERR_NOT_FOUND"
    end
end

function clear_trash(space_id, user_id, admin)
    -- item 911
    local message = check_write_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 912
    if message then
        -- item 3111
        return message
    else
        -- item 914
        db.begin()
        -- item 3109
        local folders = get_trash_folders(
        	space_id
        )
        for _, folder_id in ipairs(folders) do
            -- item 935
            delete_forever(
            	space_id,
            	folder_id
            )
            -- item 3110
            remove_from_trash(
            	space_id,
            	folder_id
            )
        end
        -- item 938
        db.commit()
        -- item 939
        return nil
    end
end

function compare_fdata(left, right)
    -- item 1029
    local result = utf8.ncasecmp(
    	left.fdata.name,
    	right.fdata.name
    )
    -- item 1033
    return result < 0
end

function copyNotNil(src, name, dst)
    -- item 1878
    local value = src[name]
    -- item 1875
    if value == nil then
        
    else
        -- item 1879
        dst[name] = value
    end
end

function copy_folder(space_id, folder_id, dst_space_id, dst_folder_id, user_id, plan)
    -- item 2298
    fiber.yield()
    -- item 2300
    db.begin()
    -- item 2032
    local new_id
    local ok = true
    local message = nil
    -- item 1122
    local fdata = db.folder_get(
    	space_id,
    	folder_id
    )
    -- item 1149
    ok, new_id = create_folder_kernel(
    	dst_space_id,
    	fdata,
    	user_id,
    	fdata.version or 0,
    	dst_folder_id
    )
    -- item 2034
    if ok then
        -- item 1769
        local my_items = db.item_get_by_folder(
        	space_id,
        	folder_id
        )
        for _, item in ipairs(my_items) do
            -- item 1290
            local item_id = item[3]
            local idata = item[4]
            -- item 1287
            db.item_insert(
            	dst_space_id,
            	new_id,
            	item_id,
            	idata
            )
        end
        -- item 2299
        db.commit()
        -- item 2304
        local children = plan[folder_id]
        -- item 2303
        if children then
            for child_id, _ in pairs(children) do
                -- item 1152
                ok, message = copy_folder(
                	space_id,
                	child_id,
                	dst_space_id,
                	new_id,
                	user_id,
                	plan
                )
                -- item 2038
                if ok then
                    
                else
                    break
                end
            end
        end
    else
        -- item 2301
        db.rollback()
        -- item 2037
        message = new_id
    end
    -- item 2033
    return ok, message
end

function copy_many(items, dst_space_id, dst_folder_id, user_id, admin)
    -- item 2028
    local ok, message
    -- item 1066
    message = check_dst_folder(
    	dst_space_id,
    	dst_folder_id,
    	user_id,
    	admin
    )
    -- item 1067
    if message then
        -- item 1055
        return message
    else
        for _, item in ipairs(items) do
            -- item 1083
            local sdata = find_folder(
            	item.space_id,
            	item.id
            )
            -- item 1084
            if sdata then
                
            else
                -- item 1085
                message = "ERR_NOT_FOUND"
                -- item 1055
                return message
            end
            -- item 1078
            message = check_read_access(
            	item.space_id,
            	user_id,
            	admin
            )
            -- item 1081
            if message then
                -- item 1055
                return message
            end
        end
        for _, item in ipairs(items) do
            -- item 2302
            local plan = {}
            build_copy_plan(
            	item.space_id,
            	item.id,
            	plan
            )
            -- item 1155
            ok, message = copy_folder(
            	item.space_id,
            	item.id,
            	dst_space_id,
            	dst_folder_id,
            	user_id,
            	plan
            )
            -- item 2029
            if ok then
                
            else
                -- item 1055
                return message
            end
        end
        -- item 1054
        return nil
    end
end

function create_folder(space_id, fields, user_id, admin)
    -- item 2100
    local count = 0
    -- item 328
    db.begin()
    -- item 319
    local message = check_write_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 320
    if message then
        -- item 331
        db.rollback()
        -- item 330
        return false, message, count
    else
        -- item 3142
        local parent_id = extract_parent_id(
        	fields
        )
        -- item 339
        local ok, result, dcount = create_folder_kernel(
        	space_id,
        	fields,
        	user_id,
        	current_version,
        	parent_id
        )
        -- item 504
        if ok then
            -- item 335
            db.commit()
            -- item 336
            return true, result
        else
            -- item 1148
            message = result
            count = dcount
            -- item 331
            db.rollback()
            -- item 330
            return false, message, count
        end
    end
end

function create_folder_kernel(space_id, fields, user_id, version, parent_id)
    -- item 1145
    local sdata = db.space_get(space_id)
    -- item 2023
    local diagrams = get_diagram_count(space_id)
    local limit = get_max_diagrams(sdata)
    -- item 2024
    if (diagrams >= limit) and (not (fields.type == "folder")) then
        -- item 2027
        return false, "ERR_DIAGRAM_LIMIT", diagrams + 1
    else
        -- item 1140
        local id = sdata.next_id
        sdata.next_id = id + 1
        local folder_id = tostring(id)
        -- item 2958
        db.space_update(
        	space_id,
        	sdata
        )
        -- item 1141
        local message = db_create_folder(
        	space_id,
        	folder_id,
        	fields,
        	user_id,
        	version,
        	parent_id
        )
        -- item 1143
        if message then
            -- item 1147
            return false, message
        else
            -- item 1139
            return true, folder_id
        end
    end
end

function create_space(space_id, owner)
    -- item 8
    local now = clock.time()
    -- item 7
    local sdata = {
    	public = false,
    	when_created = now,
    	when_updated = now,
    	next_id = 2
    }
    -- item 6
    db.space_insert(space_id, sdata)
    -- item 3049
    db.rights_insert(
    	space_id,
    	owner,
    	"admin",
    	{}
    )
    -- item 1156
    local fields = {
    	type = "folder",
    	name = "<root>"
    }
    -- item 17
    db_create_folder(
    	space_id,
    	root_folder_id,
    	fields,
    	"system",
    	current_version,
    	nil
    )
    -- item 1906
    log_user_event(
    	owner,
    	"create_space",
    	{space = space_id}
    )
end

function db_create_folder(space_id, folder_id, fields, user_id, version, parent_id)
    -- item 16
    local now = clock.time()
    -- item 15
    local fdata = {}
    for key, value in pairs(fields) do
        -- item 1896
        fdata[key] = value
    end
    -- item 1893
    fdata.when_created = now
    fdata.when_updated = now
    fdata.created_by = user_id
    fdata.updated_by = user_id
    fdata.version = version
    fdata.tag = ""
    -- item 14
    db.folder_insert(space_id, folder_id, fdata)
    -- item 407
    if parent_id then
        -- item 394
        return add_child(
        	space_id,
        	parent_id,
        	folder_id,
        	user_id
        )
    else
        -- item 502
        return nil
    end
end

function def_query(data, user_id, admin)
    -- item 2255
    local space_error, access, is_public = check_read_access(
    	data.space_id,
    	user_id,
    	admin
    )
    -- item 2256
    if space_error then
        -- item 2257
        return false, space_error
    else
        -- item 2282
        local lines = {}
        for _, line in ipairs(data.lines) do
            -- item 2285
            local normalized = utils.normalize_string(line)
            -- item 2286
            table.insert(lines, normalized)
        end
        -- item 2863
        local found = {}
        -- item 2864
        local match = function(sid, fid, folder)
        	folder_matches_reversed(
        		sid, fid, folder, 
        		lines, found
        	)
        end
        -- item 2865
        for_space_folders(data.space_id, match)
        -- item 2254
        return true, {
        	items = found
        }
    end
end

function delete_folder(space_id, folder_id)
    -- item 2208
    delete_items(space_id, folder_id)
    -- item 2207
    db.folder_delete(
    	space_id,
    	folder_id
    )
end

function delete_forever(space_id, folder_id)
    -- item 3128
    db.folder_tree_delete(
    	space_id,
    	folder_id
    )
    -- item 3127
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(children) do
        -- item 958
        delete_forever(space_id, child_id)
    end
    -- item 1857
    delete_folder(space_id, folder_id)
end

function delete_items(space_id, folder_id)
    -- item 2948
    local my_items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, item in ipairs(my_items) do
        -- item 1856
        local item_id = item[3]
        -- item 1852
        db.item_delete(
        	space_id,
        	folder_id,
        	item_id
        )
    end
end

function delete_many(items, user_id, admin)
    -- item 703
    local message
    local deleted = {}
    -- item 573
    db.begin()
    for _, item in ipairs(items) do
        -- item 702
        message = delete_one(
        	item.space_id,
        	item.id,
        	user_id,
        	admin,
        	deleted,
        	true
        )
        -- item 579
        if message then
            -- item 574
            db.rollback()
            -- item 583
            return message
        end
    end
    -- item 575
    db.commit()
    -- item 582
    return nil
end

function delete_one(space_id, folder_id, user_id, admin, deleted, tell_parent)
    -- item 672
    local message = nil
    -- item 676
    local key = space_id .. "/" .. folder_id
    -- item 674
    if deleted[key] then
        
    else
        -- item 677
        deleted[key] = {
        	space_id = space_id,
        	folder_id = folder_id
        }
        -- item 668
        local ok, result = can_edit_folder(
        	space_id,
        	folder_id,
        	user_id,
        	admin
        )
        -- item 669
        if ok then
            -- item 671
            local fdata = result
            -- item 682
            if tell_parent then
                -- item 3129
                db.folder_tree_delete(
                	space_id,
                	folder_id
                )
                -- item 967
                add_to_trash(
                	space_id,
                	{ folder_id }
                )
            end
            -- item 687
            local tag = make_folder_tag()
            -- item 688
            fdata.tag = tag
            remember_update(fdata, user_id)
            fdata.deleted = true
            -- item 2929
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 1496
            remove_from_recent(
            	space_id,
            	folder_id
            )
            -- item 3131
            local children = get_child_folders(
            	space_id,
            	folder_id
            )
            for _, child_id in ipairs(children) do
                -- item 697
                message = delete_one(
                	space_id,
                	child_id,
                	user_id,
                	admin,
                	deleted,
                	false
                )
                -- item 698
                if message then
                    break
                end
            end
        else
            -- item 673
            message = result
        end
    end
    -- item 701
    return message
end

function delete_recent(user_id)
    -- item 2964
    local found = db.recent_get_by_user(user_id)
    for _, item in ipairs(found) do
        -- item 2180
        local space_id = item[1]
        local folder_id = item[2]
        -- item 2181
        db.recent_delete(space_id, folder_id, user_id)
    end
    -- item 2182
    log_user_event(user_id, "delete_recent", {})
end

function delete_space(space_id, user_id, admin)
    -- item 1930
    local message = check_admin_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 1931
    if message then
        
    else
        -- item 2905
        local space = db.space_get(space_id)
        -- item 3050
        db.rights_delete_by_space(space_id)
        -- item 1993
        local folders = db.folder_get_by_space(
        	space_id
        )
        for _, folder in ipairs(folders) do
            -- item 1988
            local folder_id = folder[2]
            -- item 1987
            remove_from_recent(
            	space_id,
            	folder_id
            )
            -- item 2211
            delete_folder(
            	space_id,
            	folder_id
            )
        end
        -- item 1990
        db.space_delete(space_id)
        -- item 2292
        log_user_event(
        	user_id,
        	"vud_delete_space",
        	{space_id=space_id}
        )
    end
    -- item 1922
    return message
end

function delete_theme(user_id)
    -- item 2189
    if user_id then
        -- item 2188
        db.usettings_delete(user_id)
    end
end

function edit(space_id, folder_id, data, user_id, admin)
    -- item 282
    db.begin()
    -- item 794
    local message = nil
    -- item 789
    local ok, result = can_edit_folder(
    	space_id,
    	folder_id,
    	user_id,
    	admin
    )
    -- item 790
    if ok then
        -- item 792
        local fdata = result
        -- item 257
        if fdata.tag == data.oldTag then
            -- item 1882
            copyNotNil(data, "name", fdata)
            copyNotNil(data, "tag", fdata)
            copyNotNil(data, "background", fdata)
            copyNotNil(data, "diaLine", fdata)
            copyNotNil(data, "diaLineThickness", fdata)
            copyNotNil(data, "font", fdata)
            -- item 1279
            remember_update(fdata, user_id)
            -- item 2930
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 1844
            if data.editType == "replace" then
                -- item 1858
                delete_items(space_id, folder_id)
                for _, ritem in ipairs(data.items) do
                    -- item 1861
                    db.item_insert(
                    	space_id,
                    	folder_id,
                    	ritem.id,
                    	ritem
                    )
                end
            else
                -- item 1888
                local deleted = {}
                -- item 284
                if data.removed then
                    for _, ritem in ipairs(data.removed) do
                        -- item 2947
                        db.item_delete(
                        	space_id,
                        	folder_id,
                        	ritem
                        )
                        -- item 1889
                        deleted[ritem] = true
                    end
                end
                -- item 296
                if data.added then
                    for _, aitem in ipairs(data.added) do
                        -- item 301
                        db.item_insert(
                        	space_id,
                        	folder_id,
                        	aitem.id,
                        	aitem
                        )
                    end
                end
                -- item 290
                if data.updated then
                    for _, uitem in ipairs(data.updated) do
                        -- item 295
                        update_item(
                        	space_id,
                        	folder_id,
                        	uitem.id,
                        	uitem,
                        	deleted
                        )
                    end
                end
            end
            -- item 283
            db.commit()
            -- item 255
            return nil
        else
            -- item 272
            message = "ERR_MODIFIED"
            -- item 481
            db.rollback()
            -- item 482
            return message
        end
    else
        -- item 793
        message = result
        -- item 481
        db.rollback()
        -- item 482
        return message
    end
end

function export_folder(space_id, folder_id, folder_list, item_list)
    -- item 2363
    local fdata = find_folder(space_id, folder_id)
    -- item 2364
    if fdata then
        -- item 2367
        local folder_item = {
        	folder_id = folder_id,
        	fdata = fdata
        }
        -- item 2368
        table.insert(folder_list, folder_item)
        -- item 2949
        local my_items = db.item_get_by_folder(
        	space_id,
        	folder_id
        )
        for _, item in ipairs(my_items) do
            -- item 2373
            local item_id = item[3]
            local fields = item[4]
            -- item 2374
            local item_record = {
            	folder_id = folder_id,
            	item_id = item_id,
            	fields = fields
            }
            -- item 2375
            table.insert(item_list, item_record)
        end
    end
end

function export_space(space_id, filename)
    -- item 2346
    local folder_list = {}
    local item_list = {}
    -- item 2941
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, folder in ipairs(folders) do
        -- item 2344
        local folder_id = folder[2]
        -- item 2343
        export_folder(
        	space_id,
        	folder_id,
        	folder_list,
        	item_list
        )
    end
    -- item 2347
    local result = {
    	folders = folder_list,
    	items = item_list
    }
    -- item 2376
    utils.write_json(filename, result)
end

function extend_life(self)
    -- item 2650
    local timeout = 20
    -- item 2652
    self.expiry = os.time() + timeout
end

function extract_parent_id(fields)
    -- item 3151
    local parent_id = fields.parent
    -- item 3152
    fields.parent = nil
    -- item 3148
    if parent_id == "" then
        -- item 3153
        return nil
    else
        -- item 3154
        return parent_id
    end
end

function find_cycle(space_id, moving_id, target_id)
    while true do
        -- item 512
        if target_id then
            
        else
            -- item 520
            return false
        end
        -- item 517
        if target_id == moving_id then
            -- item 521
            return true
        end
        -- item 3172
        target_id = db.folder_tree_get(
        	space_id,
        	target_id
        )
    end
end

function find_folder(space_id, folder_id)
    -- item 347
    if folder_id then
        -- item 2927
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 372
        if (fdata) and (not (fdata.deleted)) then
            -- item 353
            return fdata
        else
            -- item 350
            return nil
        end
    else
        -- item 350
        return nil
    end
end

function find_folders(space_id, needle, user_id, admin)
    -- item 2759
    ej.info(
    	"find_folders",
    	{user_id=user_id, needle=needle,
    	space_id=space_id}
    )
    -- item 2424
    local space_error, a, p = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 2425
    if space_error then
        -- item 2427
        return false, space_error
    else
        -- item 2459
        needle = utils.normalize_string(needle)
        -- item 2443
        local folders = {}
        -- item 2441
        local match = function(sid, fid, folder)
        	folder_matches(
        		sid, fid, folder, 
        		needle, folders
        	)
        end
        -- item 2492
        for_space_folders(space_id, match)
        -- item 2451
        local result = {
        	folders = folders
        }
        -- item 2450
        return true, result
    end
end

function find_move_cycle(dst_space_id, dst_folder_id, space_id, folder_id)
    -- item 1413
    if (dst_space_id == space_id) and (find_cycle(dst_space_id, folder_id, dst_folder_id)) then
        -- item 1417
        return true
    else
        -- item 1416
        return false
    end
end

function folder_matches(space_id, folder_id, folder, needle, result)
    -- item 2489
    if norm_contains(folder.name, needle) then
        -- item 2487
        local folder_info = make_found_folder(
        	space_id,
        	folder_id,
        	folder
        )
        -- item 2486
        table.insert(result, folder_info)
    end
end

function folder_matches_reversed(space_id, folder_id, folder, lines, result)
    -- item 2860
    local name = utils.normalize_string(
    	folder.name
    )
    for _, line in ipairs(lines) do
        -- item 2857
        if utils.string_contains_words(line, name) then
            -- item 2856
            local folder_info = make_found_folder(
            	space_id,
            	folder_id,
            	folder
            )
            -- item 2855
            table.insert(result, folder_info)
            break
        end
    end
end

function for_space_folders(space_id, action)
    -- item 2942
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, row in ipairs(folders) do
        -- item 2471
        local folder_id = row[2]
        local folder = row[3]
        -- item 2473
        if ((folder) and (not (folder_id == "1"))) and (not (is_deleted(folder))) then
            -- item 2472
            action(
            	space_id,
            	folder_id,
            	folder
            )
        end
    end
end

function get_access(sdata, space_id, user_id, admin)
    -- item 96
    if admin then
        -- item 110
        return "admin"
    else
        -- item 195
        if user_id == "" then
            -- item 194
            if sdata.public then
                -- item 113
                return "read"
            else
                -- item 109
                return nil
            end
        else
            -- item 3063
            local accesses = get_accesses(
            	space_id,
            	user_id
            )
            -- item 100
            if accesses.admin then
                -- item 110
                return "admin"
            else
                -- item 103
                if accesses.write then
                    -- item 111
                    return "write"
                else
                    -- item 106
                    if accesses.read then
                        -- item 113
                        return "read"
                    else
                        -- item 194
                        if sdata.public then
                            -- item 113
                            return "read"
                        else
                            -- item 109
                            return nil
                        end
                    end
                end
            end
        end
    end
end

function get_access_for_space(space_id)
    -- item 3076
    local rights = db.rights_get_by_space(
    	space_id
    )
    -- item 3073
    local readers = {}
    local writers = {}
    local admins = {}
    for _, right in ipairs(rights) do
        -- item 3070
        local user_id = right[2]
        local access = right[3]
        -- item 30780001
        if access == "admin" then
            -- item 3086
            admins[user_id] = true
        else
            -- item 30780002
            if access == "write" then
                -- item 3087
                writers[user_id] = true
            else
                -- item 30780003
                if access == "read" then
                    
                else
                    -- item 30780004
                    error(access)
                end
                -- item 3088
                readers[user_id] = true
            end
        end
    end
    -- item 3077
    return {
    	readers = utils.set_to_list(readers),
    	writers = utils.set_to_list(writers),
    	admins = utils.set_to_list(admins)
    }
end

function get_accesses(space_id, user_id)
    -- item 3056
    local rights = db.rights_get_by_space_user(
    	space_id,
    	user_id
    )
    -- item 3053
    local accesses = {}
    for _, right in ipairs(rights) do
        -- item 3047
        local access = right[3]
        -- item 3054
        accesses[access] = true
    end
    -- item 3055
    return accesses
end

function get_actual_users(rights)
    -- item 2078
    local all = {}
    for _, right in ipairs(rights) do
        -- item 2978
        local access = right[3]
        local user_id = right[2]
        -- item 2979
        if access == "read" then
            
        else
            -- item 2982
            all[user_id] = true
        end
    end
    -- item 2077
    local all_list = utils.set_to_list(all)
    -- item 2082
    return #all_list
end

function get_admins(rights)
    -- item 2992
    local admins = {}
    for _, right in ipairs(rights) do
        -- item 2996
        local access = right[3]
        local user_id = right[2]
        -- item 2997
        if access == "admin" then
            -- item 3000
            table.insert(
            	admins,
            	user_id
            )
        end
    end
    -- item 2993
    return admins
end

function get_basic_limits()
    -- item 2145
    local product = utils.get_product("basic")
    -- item 2146
    return {
    	max_spaces = product.max_spaces,
    	max_diagrams = product.max_diagrams,
    	max_users = product.max_users
    }
end

function get_child_folders(space_id, parent_id)
    -- item 3121
    local get_folder_id = function(row)
    	return row[2]
    end
    -- item 3122
    local rows = db.folder_tree_get_by_parent(
    	space_id,
    	parent_id
    )
    -- item 3123
    local result = utils.map(
    	rows,
    	get_folder_id
    )
    -- item 3179
    return result
end

function get_children(space_id, folder_id)
    -- item 161
    local children = {}
    -- item 3133
    local kids = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(kids) do
        -- item 2919
        local cdata = db.folder_get(
        	space_id,
        	child_id
        )
        -- item 356
        if cdata then
            -- item 170
            local item = {
            	space_id = space_id,
            	id = child_id,
            	type = cdata.type,
            	name = cdata.name
            }
            -- item 171
            table.insert(children, item)
        end
    end
    -- item 162
    return children
end

function get_diagram_count(space_id)
    -- item 2014
    local count = 0
    -- item 2943
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, folder in ipairs(folders) do
        -- item 2018
        local fdata = folder[3]
        -- item 2019
        if (fdata.type == "folder") or (fdata.deleted) then
            
        else
            -- item 2022
            count = count + 1
        end
    end
    -- item 2015
    return count
end

function get_first_admin(space_id)
    -- item 2953
    local sdata = db.space_get(space_id)
    -- item 2893
    return sdata.admins[1]
end

function get_folder(space_id, folder_id, visit, user_id, admin)
    -- item 85
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 86
    if space_error then
        -- item 88
        return false, space_error
    else
        -- item 23
        local fdata = find_folder(space_id, folder_id)
        -- item 28
        if fdata then
            -- item 1455
            if ((user_id == "") or (not (visit))) or (fdata.type == "folder") then
                
            else
                -- item 1459
                add_to_recent(
                	space_id,
                	folder_id,
                	user_id
                )
            end
            -- item 137
            local path = get_path(space_id, folder_id)
            local items = get_items(space_id, folder_id)
            local children = get_children(space_id, folder_id)
            local parent = db.folder_tree_get(
            	space_id,
            	folder_id
            )
            -- item 90
            local result = {
            	id = folder_id,
            	space_id = space_id,
            	name = fdata.name,
            	background = fdata.background,
            	diaLine = fdata.diaLine,
            	diaLineThickness = fdata.diaLineThickness,
            	font = fdata.font,
            	type = fdata.type,
            	tag = fdata.tag,
            	parent = parent,
            	description = fdata.description,
            	access = access,
            	children = children,
            	items = items,
            	path = path,
            	is_public = is_public,
            	version = fdata.version or 0
            }
            -- item 138
            return true, result
        else
            -- item 89
            return false, "ERR_NOT_FOUND"
        end
    end
end

function get_item_text(item)
    -- item 2819
    local content = item.content
    -- item 2816
    if content then
        -- item 2822
        return content.txt
    else
        -- item 2820
        return ""
    end
end

function get_item_text2(item)
    -- item 2831
    local content = item.content
    -- item 2828
    if content then
        -- item 2833
        return content.txt2
    else
        -- item 2832
        return ""
    end
end

function get_items(space_id, folder_id)
    -- item 180
    local result = {}
    -- item 2950
    local my_items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, item in ipairs(my_items) do
        -- item 187
        local item_id = item[3]
        local idata = item[4]
        idata.id = item_id
        -- item 190
        table.insert(result, idata)
    end
    -- item 181
    return result
end

function get_max_access(space_id, user_id)
    -- item 3062
    local accesses = get_accesses(
    	space_id,
    	user_id
    )
end

function get_max_diagrams(sdata)
    -- item 2004
    if sdata.max_diagrams then
        -- item 2003
        return sdata.max_diagrams
    else
        -- item 2147
        local limits = get_basic_limits()
        -- item 2007
        return limits.max_diagrams
    end
end

function get_max_users(sdata)
    -- item 2059
    if sdata.max_users then
        -- item 2058
        return sdata.max_users
    else
        -- item 2149
        local limits = get_basic_limits()
        -- item 2148
        return limits.max_users
    end
end

function get_parent_id_for_restore(space_id, folder_id)
    -- item 3166
    local parent_id = db.folder_tree_get(
    	space_id,
    	folder_id
    )
    -- item 3161
    if parent_id then
        -- item 3160
        local parent = db.folder_get(
        	space_id,
        	parent_id
        )
        -- item 3167
        if parent.deleted then
            -- item 3164
            parent_id = root_folder_id
        end
    else
        -- item 3164
        parent_id = root_folder_id
    end
    -- item 3168
    return parent_id
end

function get_path(space_id, folder_id)
    -- item 144
    local path = {}
    while true do
        -- item 145
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 151
        table.insert(
        	path,
        	{
        		space_id = space_id,
        		id = folder_id,
        		name = fdata.name
        	}
        )
        -- item 3170
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 146
        if folder_id then
            
        else
            break
        end
    end
    -- item 149
    return utils.reverse(path)
end

function get_recent(user_id)
    -- item 1511
    local result = {}
    -- item 1512
    if user_id == "" then
        
    else
        -- item 2965
        local found = db.recent_get_by_user(user_id)
        for _, item in ipairs(found) do
            -- item 1521
            local record = {
                space_id = item[1],
                folder_id = item[2],
                whenOpened = item[4].when
            }
            -- item 2295
            local folder = db.folder_get(
            	record.space_id,
            	record.folder_id
            )
            -- item 1522
            record.name = folder.name
            record.type = folder.type
            record.path = get_path(
            	record.space_id,
            	record.folder_id
            )
            -- item 1524
            table.insert(result, record)
        end
        -- item 1520
        local compare_name = function(left, right)
        	local lname = left.name
        	local rname = right.name
        	local comp = utf8.ncasecmp(lname, rname)
        	return comp < 0
        end
        -- item 1766
        local compare_when = function(left, right)
        	return left.whenOpened > right.whenOpened
        end
        -- item 1523
        table.sort(
        	result,
        	compare_when
        )
    end
    -- item 1515
    return true, {
    	recent = result
    }
end

function get_search(session_id)
    -- item 2703
    return globs.searches[session_id]
end

function get_short_path(space_id, folder_id)
    -- item 2840
    local path = {}
    while true do
        -- item 2921
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 2845
        table.insert(path, fdata.name)
        -- item 3171
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 2842
        if folder_id == "1" then
            break
        end
    end
    -- item 2848
    table.insert(path, space_id)
    -- item 2843
    return utils.reverse(path)
end

function get_space_access(space_id, user_id, admin)
    -- item 2321
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 2322
    if space_error then
        -- item 2325
        return nil
    else
        -- item 2326
        return access
    end
end

function get_space_diagrams(space_id)
    -- item 2592
    local diagrams = {}
    -- item 2591
    local match = function(sid, fid, folder)
    	match_diagrams(
    		sid, fid, folder, 
    		diagrams
    	)
    end
    -- item 2593
    for_space_folders(space_id, match)
    -- item 2594
    return diagrams
end

function get_tag(space_id, folder_id)
    -- item 201
    local fdata = find_folder(space_id, folder_id)
    -- item 202
    if fdata then
        -- item 207
        return true, fdata.tag
    else
        -- item 204
        return false, "ERR_NOT_FOUND"
    end
end

function get_theme(user_id)
    -- item 213
    local row = db.usettings_get(user_id)
    -- item 214
    if row then
        -- item 218
        return true, row
    else
        -- item 217
        return true, {}
    end
end

function get_trash(space_id, user_id, admin)
    -- item 758
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 759
    if space_error then
        -- item 761
        return false, space_error
    else
        -- item 3104
        local folders = get_trash_folders(
        	space_id
        )
        -- item 770
        local result = {
        	access = access,
        	items = {}
        }
        for _, folder_id in ipairs(folders) do
            -- item 795
            local fdata = db.folder_get(space_id, folder_id)
            -- item 777
            local item = {
            	space_id = space_id,
            	id = folder_id,
            	type = fdata.type,
            	name = fdata.name
            }
            -- item 778
            table.insert(
            	result.items,
            	item
            )
        end
        -- item 771
        return true, result
    end
end

function get_trash_folders(space_id)
    -- item 3095
    local rows = db.trash_get_by_space(space_id)
    -- item 3105
    local get_folder_id = function(row)
    	return row[2]
    end
    -- item 3103
    return utils.map(
    	rows,
    	get_folder_id
    )
end

function get_tree(space_id, user_id, admin)
    -- item 994
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 995
    if space_error then
        -- item 997
        return false, space_error
    else
        -- item 1002
        local lines = {}
        -- item 1049
        local root = db.folder_get(
        	space_id,
        	"1"
        )
        -- item 1003
        add_tree_node(
        	space_id,
        	"1",
        	root,
        	0,
        	lines
        )
        -- item 1004
        local result = {
        	lines = lines
        }
        -- item 1001
        return true, result
    end
end

function get_user_limits(user_id)
    -- item 2158
    local user = vud.get_user(user_id)
    -- item 2171
    if user then
        -- item 2159
        local license = lic.get_license(user.license)
        -- item 2164
        if license then
            -- item 2163
            return license.limits
        else
            -- item 2162
            return get_basic_limits()
        end
    else
        -- item 2162
        return get_basic_limits()
    end
end

function import_space(space_id, filename, owner)
    -- item 2394
    create_space(space_id, owner)
    -- item 2937
    db.folder_delete(
    	space_id,
    	"1"
    )
    -- item 2402
    local obj = utils.read_json(filename)
    -- item 2405
    local min_id = 1
    for _, folder in ipairs(obj.folders) do
        -- item 2406
        local id = tonumber(folder.folder_id)
        -- item 2407
        min_id = math.max(min_id, id)
    end
    -- item 2408
    local next_id = min_id + 1
    for _, folder in ipairs(obj.folders) do
        -- item 2414
        db.folder_insert(
        	space_id,
        	folder.folder_id,
        	folder.fdata
        )
    end
    for _, item in ipairs(obj.items) do
        -- item 2397
        db.item_insert(
        	space_id,
        	item.folder_id,
        	item.item_id,
        	item.fields
        )
    end
    -- item 2954
    local sdata = db.space_get(space_id)
    -- item 2417
    sdata.next_id = next_id
    -- item 2959
    db.space_update(
    	space_id,
    	sdata
    )
end

function insert_items_from_map(space_id, folder_id, items_map)
    -- item 2229
    if items_map then
        for item_id, item in pairs(items_map) do
            -- item 2235
            item.id = nil
            -- item 2234
            db.item_insert(
            	space_id,
            	folder_id,
            	item_id,
            	item
            )
        end
    end
end

function is_deleted(folder)
    -- item 2439
    local deleted = not not folder.deleted
    -- item 2440
    return deleted
end

function is_diagram_like(fields, names)
    -- item 2272
    if fields.type == "folder" then
        -- item 2276
        return false
    else
        -- item 2277
        local dia_name = utils.parse_compound_name(
        	fields.name
        )
        for _, name in ipairs(names) do
            -- item 2278
            if name == dia_name then
                -- item 2280
                return true
            end
        end
        -- item 2281
        return false
    end
end

function log_user_event(user_id, type, data)
    -- item 1904
    data.user_id = user_id
    -- item 1905
    ej.info(type, data)
end

function make_folder_tag()
    -- item 392
    local t = clock.time()
    return tostring(t * 10000)
end

function make_found_folder(space_id, folder_id, folder)
    -- item 2457
    local result = {
    	space_id = space_id,
    	folder_id = folder_id,
    	name = folder.name,
    	type = folder.type,
    	path = get_short_path(space_id, folder_id)
    }
    -- item 2458
    return result
end

function match_diagrams(space_id, folder_id, folder, result)
    -- item 2544
    if folder.type == "folder" then
        
    else
        -- item 2542
        local folder_info = {
        	space_id = space_id,
        	folder_id = folder_id,
        	fields = folder
        }
        -- item 2541
        table.insert(result, folder_info)
    end
end

function move_many(items, dst_space_id, dst_folder_id, user_id, admin)
    -- item 1311
    local message = check_dst_folder(
    	dst_space_id,
    	dst_folder_id,
    	user_id,
    	admin
    )
    -- item 1312
    if message then
        -- item 1305
        return false, message
    else
        for _, item in ipairs(items) do
            -- item 1445
            if item.space_id == dst_space_id then
                
            else
                -- item 1446
                message = "ERR_CANT_MOVE_ACROSS"
                -- item 1305
                return false, message
            end
            -- item 1322
            local ok, fdata = can_edit_folder(
            	item.space_id,
            	item.id,
            	user_id,
            	admin
            )
            -- item 1323
            if ok then
                
            else
                -- item 1324
                message = fdata
                -- item 1305
                return false, message
            end
            -- item 1419
            local cycle = find_move_cycle(
            	dst_space_id,
            	dst_folder_id,
            	item.space_id,
            	item.id
            )
            -- item 1406
            if cycle then
                -- item 1407
                message = "ERR_CYCLE"
                -- item 1305
                return false, message
            end
        end
        -- item 1356
        local sorted = sort_for_move(items)
        for _, item in ipairs(sorted) do
            -- item 1427
            message = move_via_reparent(
            	item.space_id,
            	item.id,
            	dst_folder_id,
            	user_id
            )
            -- item 1357
            if message then
                -- item 1305
                return false, message
            end
        end
        -- item 1452
        local result = {
        	items = sorted
        }
        -- item 1304
        return true, result
    end
end

function move_via_reparent(space_id, folder_id, new_parent, user_id)
    -- item 1442
    db.folder_tree_upsert(
    	space_id,
    	folder_id,
    	new_parent
    )
    -- item 1439
    return nil
end

function multi_access(data, user_id, admin)
    for _, block in ipairs(data.blocks) do
        -- item 1755
        local grant = (block.action == "grant")
        -- item 1745
        local message, count = access_core(
        	block,
        	grant,
        	user_id,
        	admin
        )
        -- item 1746
        if message then
            -- item 1751
            return message, count
        end
    end
    -- item 1756
    if data.setPublicAccess then
        -- item 1759
        local sdata = db.space_get(data.spaceId)
        sdata.public = data.publicAccess
        -- item 2960
        db.space_update(
        	data.spaceId,
        	sdata
        )
        -- item 1907
        log_user_event(
        	user_id,
        	"public access",
        	{space=data.spaceId, public=sdata.public}
        )
    end
    -- item 1750
    return nil
end

function norm_contains(haystack, needle)
    -- item 2793
    if haystack then
        -- item 2791
        local norm_haystack = utils.normalize_string(
        	haystack
        )
        -- item 2792
        return utils.string_contains(
        	norm_haystack,
        	needle
        )
    else
        -- item 2796
        return false
    end
end

function read_access(space_id, user_id, admin)
    -- item 1603
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 1604
    if space_error then
        -- item 1606
        return false, space_error
    else
        -- item 1607
        local sdata = db.space_get(space_id)
        -- item 3089
        local result = get_access_for_space(
        	space_id
        )
        -- item 1608
        result.public = sdata.public
        -- item 1601
        return true, result
    end
end

function remember_update(fields, user_id)
    -- item 1277
    fields.updated_by = user_id
    fields.when_updated = clock.time()
end

function remove_from_recent(space_id, folder_id)
    -- item 2966
    local found = db.recent_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, record in ipairs(found) do
        -- item 1492
        local user_id = record[3]
        -- item 1491
        db.recent_delete(
        	space_id,
        	folder_id,
        	user_id
        )
        -- item 1991
        log.info("deleted: " .. folder_id)
    end
end

function remove_from_trash(space_id, folder_id)
    -- item 3107
    db.trash_delete(space_id, folder_id)
end

function restore(space_id, folder_id, user_id, admin)
    -- item 823
    db.begin()
    -- item 867
    local message = check_write_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 868
    if message then
        -- item 855
        db.rollback()
        -- item 856
        return message
    else
        -- item 2922
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 865
        if fdata then
            -- item 812
            if fdata.deleted then
                -- item 872
                local parent_id = get_parent_id_for_restore(
                	space_id,
                	folder_id
                )
                -- item 878
                local tag = make_folder_tag()
                -- item 816
                fdata.tag = tag
                fdata.deleted = false
                -- item 1281
                remember_update(fdata, user_id)
                -- item 3169
                db.folder_tree_upsert(
                	space_id,
                	folder_id,
                	parent_id
                )
                -- item 2933
                db.folder_update(
                	space_id,
                	folder_id,
                	fdata
                )
                -- item 3135
                local children = get_child_folders(
                	space_id,
                	folder_id
                )
                for _, child_id in ipairs(children) do
                    -- item 971
                    restore_recursive(
                    	space_id,
                    	child_id
                    )
                end
                -- item 880
                add_child(
                	space_id,
                	parent_id,
                	folder_id,
                	user_id
                )
                -- item 895
                remove_from_trash(
                	space_id,
                	folder_id
                )
                -- item 824
                db.commit()
                -- item 811
                return nil
            else
                -- item 813
                message = "ERR_NOT_DELETED"
                -- item 855
                db.rollback()
                -- item 856
                return message
            end
        else
            -- item 866
            message = "ERR_NOT_FOUND"
            -- item 855
            db.rollback()
            -- item 856
            return message
        end
    end
end

function restore_recursive(space_id, folder_id)
    -- item 982
    local fdata = db.folder_get(
    	space_id,
    	folder_id
    )
    -- item 983
    fdata.deleted = false
    -- item 2934
    db.folder_update(
    	space_id,
    	folder_id,
    	fdata
    )
    -- item 3137
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(children) do
        -- item 979
        restore_recursive(
        	space_id,
        	child_id
        )
    end
end

function save_try(data, user_id)
    -- item 1559
    local space_id = user_id
    local count = 0
    -- item 1582
    db.begin()
    -- item 1543
    local message = check_write_access(
    	space_id,
    	user_id,
    	false
    )
    -- item 1556
    if message then
        -- item 1554
        db.rollback()
        -- item 2239
        log_user_event(
        	user_id,
        	"save_try-failed",
        	{message=message}
        )
        -- item 1555
        return false, message, count
    else
        -- item 1565
        local fields = {
        	type = data.type,
        	name = data.name,
        	background = data.background,
        	diaLine = data.diaLine,
        	diaLineThickness = data.diaLineThickness,
        	font = data.font
        }
        -- item 1560
        local ok, folder_id, dcount = create_folder_kernel(
        	space_id,
        	fields,
        	user_id,
        	current_version,
        	root_folder_id
        )
        -- item 1563
        if ok then
            -- item 2236
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.free
            )
            -- item 2237
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.nodes
            )
            -- item 2238
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.edges
            )
            -- item 1561
            db.commit()
            -- item 1562
            return true, folder_id, 0
        else
            -- item 1567
            message = folder_id
            count = dcount
            -- item 1554
            db.rollback()
            -- item 2239
            log_user_event(
            	user_id,
            	"save_try-failed",
            	{message=message}
            )
            -- item 1555
            return false, message, count
        end
    end
end

function search_add(session_id, search)
    -- item 2548
    search_delete(session_id)
    -- item 2535
    globs.searches[session_id] = search
end

function search_delete(session_id)
    -- item 2722
    local search = globs.searches[session_id]
    -- item 2723
    if search then
        -- item 2726
        search.state = nil
        -- item 2727
        globs.searches[session_id] = nil
    end
end

function search_items_get(session_id)
    -- item 2704
    local search = get_search(session_id)
    -- item 2706
    if search then
        -- item 2705
        local result = {}
        -- item 2710
        search:get(result)
        -- item 2711
        return result
    else
        -- item 2757
        return nil
    end
end

function search_items_start(session_id, space_id, needle, user_id, admin)
    -- item 2758
    ej.info(
    	"search_items_start",
    	{user_id=user_id, needle=needle,
    	space_id=space_id}
    )
    -- item 2508
    local space_error, a, p = check_read_access(
    	space_id,
    	user_id,
    	admin
    )
    -- item 2509
    if space_error then
        -- item 2743
        return false, space_error
    else
        -- item 2751
        local norm_needle = utils.normalize_string(
        	needle
        )
        -- item 2754
        local diagrams = get_space_diagrams(
        	space_id
        )
        -- item 2712
        local msg = {
        	space_id = space_id,
        	needle = norm_needle,
        	session_id = session_id,
        	diagrams = diagrams
        }
        -- item 2515
        local search = search_machine()
        -- item 2714
        search:update(msg)
        -- item 2968
        local run_search = function ()
        	search_loop(search)
        end
        -- item 2967
        db.run_in_fiber(
        	run_search,
        	"search"
        )
        -- item 2744
        return true, {}
    end
end

function search_loop(search)
    while true do
        -- item 2735
        fiber.sleep(search_yield)
        -- item 2733
        if search.state then
            
        else
            break
        end
        -- item 2736
        local now = os.time()
        -- item 2737
        if now > search.expiry then
            break
        end
        -- item 2734
        search:update(nil)
    end
end

function search_machine_completed_default(self, msg)
    -- item 2685
    self.state = "completed"
end

function search_machine_completed_get(self, msg)
    -- item 2690
    take_found_items(self, msg)
    -- item 2756
    msg.completed = true
    -- item 2746
    search_delete(self.session_id)
    -- item 2673
    self.state = nil
end

function search_machine_init_default(self, msg)
    -- item 2634
    self.state = "init"
end

function search_machine_init_update(self, msg)
    -- item 2659
    self.items = {}
    self.session_id = msg.session_id
    self.needle = msg.needle
    self.diagrams = msg.diagrams
    self.current = 1
    -- item 2651
    extend_life(self)
    -- item 2745
    search_add(
    	self.session_id,
    	self
    )
    -- item 2573
    self.state = "scanning"
end

function search_machine_scanning_get(self, msg)
    -- item 2665
    take_found_items(self, msg)
    -- item 2755
    msg.completed = false
    -- item 2664
    extend_life(self)
    -- item 2663
    self.state = "scanning"
end

function search_machine_scanning_update(self, msg)
    -- item 2653
    if self.current > #self.diagrams then
        -- item 2655
        self.state = "completed"
    else
        -- item 2657
        local diagram = self.diagrams[self.current]
        -- item 2658
        search_scan_items(
        	diagram,
        	self.needle,
        	self.items
        )
        -- item 2656
        self.current = self.current + 1
        -- item 2576
        self.state = "scanning"
    end
end

function search_scan_items(diagram, needle, result)
    -- item 2834
    local space_id = diagram.space_id
    local folder_id = diagram.folder_id
    local fields = diagram.fields
    -- item 2784
    local match
    -- item 2774
    local found = {}
    -- item 2775
    local items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, item_row in ipairs(items) do
        -- item 2778
        local item_id = item_row[3]
        local item = item_row[4]
        -- item 2849
        if item.role == "header" then
            
        else
            -- item 2785
            local text = get_item_text(item)
            local text2 = get_item_text2(item)
            -- item 2797
            if norm_contains(text, needle) then
                -- item 2783
                match = {
                	item_id = item_id,
                	text = text
                }
                -- item 2782
                table.insert(found, match)
            else
                -- item 2800
                if norm_contains(text2, needle) then
                    -- item 2802
                    match = {
                    	item_id = item_id,
                    	text = text2
                    }
                    -- item 2782
                    table.insert(found, match)
                end
            end
        end
    end
    -- item 2803
    if #found == 0 then
        
    else
        -- item 2808
        local path = get_short_path(
        	space_id,
        	folder_id
        )
        for _, match in ipairs(found) do
            -- item 2809
            match.space_id = space_id
            match.folder_id = folder_id
            match.name = fields.name
            match.type = fields.type
            match.path = path
            -- item 2810
            table.insert(result, match)
        end
    end
end

function set_space_limits(space_id, max_diagrams, max_users)
    -- item 2046
    local sdata = db.space_get(space_id)
    -- item 2047
    sdata.max_diagrams = max_diagrams
    sdata.max_users = max_users
    -- item 2962
    db.space_update(
    	space_id,
    	sdata
    )
end

function set_theme(user_id, settings)
    -- item 2963
    local data = db.usettings_get(user_id)
    -- item 225
    if data then
        
    else
        -- item 235
        data = {}
    end
    -- item 1880
    copyNotNil(settings, "theme", data)
    copyNotNil(settings, "language", data)
    copyNotNil(settings, "zoom", data)
    copyNotNil(settings, "toolbar", data)
    copyNotNil(settings, "toolbarFree", data)
    copyNotNil(settings, "shape", data)
    copyNotNil(settings, "font", data)
    copyNotNil(settings, "background", data)
    copyNotNil(settings, "diaLine", data)
    copyNotNil(settings, "colors", data)
    copyNotNil(settings, "yes", data)
    copyNotNil(settings, "no", data)
    copyNotNil(settings, "end", data)
    -- item 234
    db.usettings_upsert(
    	user_id,
    	data
    )
end

function sort_for_move(items)
    -- item 1365
    local add_depth = function(item)
    	local depth = calculate_depth(
    		item.space_id,
    		item.id
    	)
    	return {
    		id = item.id,
    		space_id = item.space_id,
    		depth = depth
    	}
    end
    -- item 1367
    local result = fun.totable(fun.map(
    	add_depth,
    	items
    ))
    -- item 1366
    local compare_depth = function(left, right)
    	return left.depth > right.depth
    end
    -- item 1368
    table.sort(
    	result,
    	compare_depth
    )
    -- item 1369
    return result
end

function space_exists(space_id, user_id, admin)
    -- item 2955
    local sdata = db.space_get(space_id)
    -- item 1626
    if sdata then
        -- item 1631
        return true
    else
        -- item 1632
        return false
    end
end

function take_found_items(self, dst)
    -- item 2671
    dst.items = self.items
    self.items = {}
end

function top_spaces()
    -- item 2870
    local spaces = db.space_get_all()
    -- item 2874
    local result = {}
    for _, space_row in ipairs(spaces) do
        -- item 2887
        local space_id = space_row[1]
        local admin = get_first_admin(space_id)
        local email = db.user_get_email(admin) or ""
        -- item 2873
        local count = get_diagram_count(space_id)
        local item = {
        	space_id = space_id,
        	user = admin,
        	email = email,
        	count = count
        }
        -- item 2875
        table.insert(result, item)
    end
    -- item 2882
    table.sort(result, by_count)
    -- item 2896
    local txt = ""
    for _, item in ipairs(result) do
        -- item 2897
        txt = txt .. item.space_id .. "\t"
          .. item.user .. "\t"
          .. item.email .. "\t"
          .. item.count .. "\n"
    end
    -- item 2883
    return txt
end

function update_folder(space_id, folder_id, fields, user_id, admin)
    -- item 438
    db.begin()
    -- item 666
    local message
    -- item 435
    local ok, result = can_edit_folder(
    	space_id,
    	folder_id,
    	user_id,
    	admin
    )
    -- item 436
    if ok then
        -- item 454
        local fdata = result
        -- item 3174
        local old_parent = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 486
        local tag = make_folder_tag()
        -- item 1590
        remember_update(fdata, user_id)
        -- item 1868
        copyNotNil(fields, "name", fdata)
        copyNotNil(fields, "tag", fdata)
        copyNotNil(fields, "background", fdata)
        copyNotNil(fields, "font", fdata)
        copyNotNil(fields, "description", fdata)
        -- item 3173
        local new_parent = extract_parent_id(
        	fields
        )
        -- item 459
        if (new_parent) and (not (new_parent == old_parent)) then
            -- item 524
            if find_cycle(space_id, folder_id, new_parent) then
                -- item 526
                message = "ERR_CYCLE"
                -- item 440
                db.rollback()
                -- item 439
                return message
            else
                -- item 484
                message = add_child(
                	space_id,
                	new_parent,
                	folder_id,
                	user_id
                )
                -- item 492
                if message then
                    -- item 440
                    db.rollback()
                    -- item 439
                    return message
                else
                    -- item 487
                    fdata.tag = tag
                    -- item 1282
                    remember_update(fdata, user_id)
                    -- item 2935
                    db.folder_update(
                    	space_id,
                    	folder_id,
                    	fdata
                    )
                    -- item 444
                    db.commit()
                    -- item 445
                    return nil
                end
            end
        else
            -- item 487
            fdata.tag = tag
            -- item 1282
            remember_update(fdata, user_id)
            -- item 2935
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 444
            db.commit()
            -- item 445
            return nil
        end
    else
        -- item 667
        message = result
        -- item 440
        db.rollback()
        -- item 439
        return message
    end
end

function update_folder_tag(space_id, folder_id, tag, user_id)
    -- item 788
    local fdata = db.folder_get(space_id, folder_id)
    -- item 1283
    remember_update(fdata, user_id)
    -- item 379
    fdata.tag = tag
    -- item 2936
    db.folder_update(
    	space_id,
    	folder_id,
    	fdata
    )
end

function update_item(space_id, folder_id, item_id, new_data, deleted)
    -- item 415
    local idata = db.item_get(
    	space_id,
    	folder_id,
    	item_id
    )
    -- item 1883
    if idata then
        for key, value in pairs(new_data) do
            -- item 418
            idata[key] = value
        end
        -- item 419
        db.item_update(
        	space_id,
        	folder_id,
        	item_id,
        	idata
        )
    else
        -- item 1886
        log.error("item not found " .. item_id)
        -- item 1890
        if deleted[item_id] then
            
        else
            for key, value in pairs(new_data) do
                -- item 418
                idata[key] = value
            end
            -- item 419
            db.item_update(
            	space_id,
            	folder_id,
            	item_id,
            	idata
            )
        end
    end
end

function update_space_limits(space_id)
    -- item 3031
    local rights = db.rights_get_by_space(
    	space_id
    )
    -- item 3032
    local admins = get_admins(rights)
    -- item 3030
    update_space_limits_core(
    	space_id,
    	admins
    )
end

function update_space_limits_core(space_id, admins)
    -- item 3025
    local max_users = 0
    local max_diagrams = 0
    for _, user_id in ipairs(admins) do
        -- item 3026
        local ulimits = get_user_limits(user_id)
        -- item 3027
        max_users = math.max(
        	max_users,
        	ulimits.max_users
        )
        -- item 3028
        max_diagrams = math.max(
        	max_diagrams,
        	ulimits.max_diagrams
        )
    end
    -- item 3029
    set_space_limits(
    	space_id,
    	max_diagrams,
    	max_users
    )
end


function search_machine()
    local obj = {}
    obj.type_name = "search_machine"
    obj.state = "init"
    obj.get = function(self, msg)
        local _state_ = self.state
        if _state_ == "init" then
            return search_machine_init_default(self, msg)
        elseif _state_ == "scanning" then
            return search_machine_scanning_get(self, msg)
        elseif _state_ == "completed" then
            return search_machine_completed_get(self, msg)
        end
        return nil
    end
    obj.update = function(self, msg)
        local _state_ = self.state
        if _state_ == "init" then
            return search_machine_init_update(self, msg)
        elseif _state_ == "scanning" then
            return search_machine_scanning_update(self, msg)
        elseif _state_ == "completed" then
            return search_machine_completed_default(self, msg)
        end
        return nil
    end
    return obj
end

return {
	create_space = create_space,
	get_folder = get_folder,
	get_tag = get_tag,
	get_theme = get_theme,
	set_theme = set_theme,
	edit = edit,
	create_folder = create_folder,
	update_folder = update_folder,
	delete_many = delete_many,
	copy_many = copy_many,
	move_many = move_many,
	get_trash = get_trash,
	restore = restore,
	clear_trash = clear_trash,
	get_tree = get_tree,
	access = access,
	get_recent = get_recent,
	save_try = save_try,
	read_access = read_access,
	space_exists = space_exists,
	multi_access = multi_access,
	delete_space = delete_space,
	set_space_limits = set_space_limits,
	update_space_limits = update_space_limits,
	get_user_limits = get_user_limits,
	delete_recent = delete_recent,
	delete_theme = delete_theme,
	remove_user = remove_user,
	def_query = def_query,
	get_space_access = get_space_access,
	export_space = export_space,
	import_space = import_space,
	find_folders = find_folders,
	search_delete = search_delete,
	search_items_start = search_items_start,
	search_items_get = search_items_get,
	top_spaces = top_spaces
}
